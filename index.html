<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Compressor - WebCodecs & MP4 Muxer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .upload-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
            margin-bottom: 20px;
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
        }

        .file-input-label:hover {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
        }

        .file-input-text {
            font-size: 1.2rem;
            text-align: center;
        }

        .controls-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .settings-header h2 {
            margin: 0;
            font-size: 1.8rem;
        }

        .settings-mode-toggle {
            display: flex;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 4px;
        }

        .mode-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
        }

        .mode-btn:hover {
            color: white;
        }

        .mode-btn-active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white !important;
        }

        .settings-panel {
            display: block;
        }

        .settings-panel.hidden {
            display: none;
        }

        .basic-description {
            text-align: center;
            margin-bottom: 30px;
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .file-size-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .file-size-btn {
            padding: 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            text-align: center;
        }

        .file-size-btn:hover {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
            transform: translateY(-2px);
        }

        .file-size-btn.file-size-active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border-color: #4ecdc4;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
        }

        .size-number {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .size-description {
            font-size: 1rem;
            margin-bottom: 5px;
            opacity: 0.9;
        }

        .size-details {
            font-size: 0.85rem;
            opacity: 0.7;
        }

        .basic-audio-control {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        .audio-toggle {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .audio-toggle input {
            display: none;
        }

        .audio-toggle-slider {
            position: relative;
            width: 50px;
            height: 24px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            transition: all 0.3s ease;
            margin-right: 12px;
        }

        .audio-toggle-slider:before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .audio-toggle input:checked + .audio-toggle-slider {
            background: #4ecdc4;
        }

        .audio-toggle input:checked + .audio-toggle-slider:before {
            transform: translateX(26px);
        }

        .audio-toggle-label {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            margin-bottom: 8px;
            font-weight: 600;
            color: #4ecdc4;
        }

        .control-group input,
        .control-group select {
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 0 2px rgba(78, 205, 196, 0.3);
        }

        .preview-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .video-preview {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .video-container {
            text-align: center;
        }

        .video-container h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
        }

        .video-container video {
            width: 100%;
            max-height: 300px;
            border-radius: 10px;
            background: #000;
        }

        .video-info {
            margin-top: 10px;
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .progress-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            font-size: 1.1rem;
        }

        .log-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .log-entry.error {
            color: #ff6b6b;
        }

        .log-entry.success {
            color: #4ecdc4;
        }

        .log-entry.warning {
            color: #feca57;
        }

        @media (max-width: 768px) {
            .video-preview {
                grid-template-columns: 1fr;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .action-buttons {
                flex-direction: column;
            }
            
            .settings-header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            
            .file-size-options {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .file-size-btn {
                padding: 15px;
            }
            
            .settings-mode-toggle {
                justify-content: center;
            }
        }

        .hidden {
            display: none !important;
        }

        .file-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .file-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .file-info-item {
            text-align: center;
        }

        .file-info-item .label {
            color: #4ecdc4;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .file-info-item .value {
            font-size: 1.1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé¨ Video Compressor</h1>
            <p>Compress videos locally using WebCodecs API & MP4 Muxer</p>
        </div>

        <!-- Upload Section -->
        <div class="upload-section">
            <div class="file-input-wrapper">
                <input type="file" id="videoInput" class="file-input" accept="video/*">
                <label for="videoInput" class="file-input-label">
                    <div class="file-input-text">
                        üìÅ Click to select a video file or drag & drop here
                    </div>
                </label>
            </div>
            
            <div id="fileInfo" class="file-info hidden">
                <div class="file-info-grid">
                    <div class="file-info-item">
                        <div class="label">File Name</div>
                        <div class="value" id="fileName">-</div>
                    </div>
                    <div class="file-info-item">
                        <div class="label">File Size</div>
                        <div class="value" id="fileSize">-</div>
                    </div>
                    <div class="file-info-item">
                        <div class="label">Duration</div>
                        <div class="value" id="fileDuration">-</div>
                    </div>
                    <div class="file-info-item">
                        <div class="label">Resolution</div>
                        <div class="value" id="fileResolution">-</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Controls Section -->
        <div class="controls-section">
            <div class="settings-header">
                <h2>üéõÔ∏è Compression Settings</h2>
                <div class="settings-mode-toggle">
                    <button class="mode-btn mode-btn-active" id="basicModeBtn">üì± Basic</button>
                    <button class="mode-btn" id="advancedModeBtn">‚öôÔ∏è Advanced</button>
                </div>
            </div>
            
            <!-- Basic Settings -->
            <div id="basicSettings" class="settings-panel">
                <div class="basic-description">
                    <p>Choose your target file size. We'll automatically optimize the video settings for the best quality within that limit.</p>
                </div>
                
                <div class="file-size-options">
                    <button class="file-size-btn file-size-active" data-size="8" id="size8mb">
                        <div class="size-number">8 MB</div>
                        <div class="size-description">Perfect for sharing</div>
                        <div class="size-details">Good quality ‚Ä¢ Fast upload</div>
                    </button>
                    
                    <button class="file-size-btn" data-size="25" id="size25mb">
                        <div class="size-number">25 MB</div>
                        <div class="size-description">Balanced quality</div>
                        <div class="size-details">Higher quality ‚Ä¢ Moderate size</div>
                    </button>
                    
                    <button class="file-size-btn" data-size="50" id="size50mb">
                        <div class="size-number">50 MB</div>
                        <div class="size-description">High quality</div>
                        <div class="size-details">Best quality ‚Ä¢ Larger file</div>
                    </button>
                </div>
                
                <div class="basic-audio-control">
                    <label class="audio-toggle">
                        <input type="checkbox" id="basicIncludeAudio" checked>
                        <span class="audio-toggle-slider"></span>
                        <span class="audio-toggle-label">üéµ Include Audio</span>
                    </label>
                </div>
            </div>
            
            <!-- Advanced Settings -->
            <div id="advancedSettings" class="settings-panel hidden">
                <div class="controls-grid">
                    <div class="control-group">
                        <label for="codec">Video Codec</label>
                        <select id="codec">
                            <option value="avc1.42E01E">H.264 (AVC) - Best Compatibility</option>
                            <option value="hev1.1.6.L93.B0">H.265 (HEVC) - Better Compression</option>
                            <option value="vp09.00.10.08">VP9 - Open Source</option>
                            <option value="av01.0.04M.08">AV1 - Latest Standard</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="quality">Quality Level</label>
                        <select id="quality">
                            <option value="high">High Quality</option>
                            <option value="medium" selected>Medium Quality</option>
                            <option value="low">Low Quality</option>
                            <option value="custom">Custom Bitrate</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="bitrate">Bitrate (Mbps)</label>
                        <input type="number" id="bitrate" value="2" min="0.1" max="50" step="0.1">
                    </div>
                    
                    <div class="control-group">
                        <label for="resolution">Output Resolution</label>
                        <select id="resolution">
                            <option value="original">Keep Original</option>
                            <option value="1920x1080">1080p (1920x1080)</option>
                            <option value="1280x720">720p (1280x720)</option>
                            <option value="854x480">480p (854x480)</option>
                            <option value="640x360">360p (640x360)</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="includeAudio">Include Audio</label>
                        <select id="includeAudio">
                            <option value="true" selected>Yes - Include Audio</option>
                            <option value="false">No - Video Only</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="audioBitrate">Audio Bitrate (kbps)</label>
                        <select id="audioBitrate">
                            <option value="64">64 kbps - Low Quality</option>
                            <option value="128" selected>128 kbps - Standard</option>
                            <option value="192">192 kbps - High Quality</option>
                            <option value="256">256 kbps - Very High Quality</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <!-- Preview Section -->
        <div class="preview-section hidden" id="previewSection">
            <h2>üì∫ Video Preview</h2>
            <div class="video-preview">
                <div class="video-container">
                    <h3>Original Video</h3>
                    <video id="originalVideo" controls muted></video>
                    <div class="video-info" id="originalInfo">
                        Loading...
                    </div>
                </div>
                <div class="video-container">
                    <h3>Compressed Video</h3>
                    <video id="compressedVideo" controls muted></video>
                    <div class="video-info" id="compressedInfo">
                        Not compressed yet
                    </div>
                </div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons">
            <button class="btn btn-primary" id="compressBtn" disabled>
                üîß Compress Video
            </button>
            <button class="btn btn-secondary hidden" id="downloadBtn" disabled>
                üíæ Download Compressed Video
            </button>
        </div>

        <!-- Progress Section -->
        <div class="progress-section" id="progressSection">
            <h2>‚ö° Processing...</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Preparing...</div>
        </div>

        <!-- Log Section -->
        <div class="log-section">
            <div id="logContainer"></div>
        </div>
    </div>

    <!-- Import MP4 Muxer -->
    <script src="mp4-muxer.js" id="mp4MuxerScript"></script>
    
    <script>
        // Track script loading
        let mp4MuxerLoaded = false;
        let initializationAttempted = false;

        // Listen for script load events
        document.getElementById('mp4MuxerScript').addEventListener('load', function() {
            console.log('‚úÖ mp4-muxer.js script loaded successfully');
            mp4MuxerLoaded = true;
            
            // Check if Mp4Muxer is available immediately after load
            if (typeof Mp4Muxer !== 'undefined') {
                console.log('‚úÖ Mp4Muxer global variable is available');
            } else {
                console.warn('‚ö†Ô∏è Mp4Muxer global variable not found after script load');
            }
            
            // If initialization was already attempted, try again
            if (initializationAttempted) {
                initializeApp();
            }
        });

        document.getElementById('mp4MuxerScript').addEventListener('error', function() {
            console.error('‚ùå Failed to load mp4-muxer.js script');
            showError('Failed to load the MP4 muxer script file. Please check if the file exists and try refreshing the page.');
        });

        // Global variables
        let originalVideoFile = null;
        let originalVideo = null;
        let compressedVideoBlob = null;
        let isProcessing = false;
        let currentSettingsMode = 'basic'; // Track current mode
        let selectedTargetSize = 8; // Default target size in MB

        // DOM elements
        const videoInput = document.getElementById('videoInput');
        const fileInfo = document.getElementById('fileInfo');
        const previewSection = document.getElementById('previewSection');
        const originalVideoEl = document.getElementById('originalVideo');
        const compressedVideoEl = document.getElementById('compressedVideo');
        const compressBtn = document.getElementById('compressBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const progressSection = document.getElementById('progressSection');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const logContainer = document.getElementById('logContainer');

        // Settings mode elements
        const basicModeBtn = document.getElementById('basicModeBtn');
        const advancedModeBtn = document.getElementById('advancedModeBtn');
        const basicSettings = document.getElementById('basicSettings');
        const advancedSettings = document.getElementById('advancedSettings');
        const fileSizeBtns = document.querySelectorAll('.file-size-btn');

        // Quality presets
        const qualityPresets = {
            high: { bitrate: 8, description: 'High quality, larger file size' },
            medium: { bitrate: 2, description: 'Balanced quality and file size' },
            low: { bitrate: 0.8, description: 'Lower quality, smaller file size' }
        };

        // Initialize with proper timing and script loading detection
        document.addEventListener('DOMContentLoaded', function() {
            initializationAttempted = true;
            initializeApp();
        });

        function initializeApp() {
            log('üöÄ Video Compressor initializing...', 'success');
            
            // Wait a bit longer for script to be fully processed
            setTimeout(() => {
                debugLibraryLoading();
                if (checkWebCodecsSupport()) {
                    setupEventListeners();
                    setupDragAndDrop();
                    checkCodecSupport();
                    loadUserPreferences();
                    log('üéâ Video Compressor ready!', 'success');
                } else {
                    log('‚ùå Video Compressor initialization failed', 'error');
                }
            }, 200);
        }

        function loadUserPreferences() {
            // Load saved settings mode preference
            const savedMode = localStorage.getItem('videoCompressorMode');
            if (savedMode === 'advanced') {
                switchToAdvancedMode();
            } else {
                switchToBasicMode();
            }
            
            // Load saved target size for basic mode
            const savedSize = localStorage.getItem('videoCompressorTargetSize');
            if (savedSize) {
                selectedTargetSize = parseInt(savedSize);
                updateSelectedSize();
            }
            
            log(`üìã Loaded user preferences: ${currentSettingsMode} mode`, 'info');
        }

        function switchToBasicMode() {
            currentSettingsMode = 'basic';
            basicModeBtn.classList.add('mode-btn-active');
            advancedModeBtn.classList.remove('mode-btn-active');
            basicSettings.classList.remove('hidden');
            advancedSettings.classList.add('hidden');
            localStorage.setItem('videoCompressorMode', 'basic');
            log('üì± Switched to Basic mode', 'info');
        }

        function switchToAdvancedMode() {
            currentSettingsMode = 'advanced';
            advancedModeBtn.classList.add('mode-btn-active');
            basicModeBtn.classList.remove('mode-btn-active');
            advancedSettings.classList.remove('hidden');
            basicSettings.classList.add('hidden');
            localStorage.setItem('videoCompressorMode', 'advanced');
            log('‚öôÔ∏è Switched to Advanced mode', 'info');
        }

        function updateSelectedSize() {
            fileSizeBtns.forEach(btn => {
                const size = parseInt(btn.dataset.size);
                if (size === selectedTargetSize) {
                    btn.classList.add('file-size-active');
                } else {
                    btn.classList.remove('file-size-active');
                }
            });
        }

        function calculateBasicSettings(targetSizeMB, duration, originalWidth, originalHeight, includeAudio) {
            // Convert target size to bits
            const targetSizeBits = targetSizeMB * 8 * 1000 * 1000;
            
            // Reserve space for audio if included
            const audioBitrate = includeAudio ? 128000 : 0; // 128 kbps for audio
            const audioSizeBits = duration * audioBitrate;
            
            // Calculate available space for video
            const videoSizeBits = Math.max(targetSizeBits - audioSizeBits, targetSizeBits * 0.7);
            
            // Calculate video bitrate
            const videoBitrate = Math.max(videoSizeBits / duration, 100000); // Min 100kbps
            
            // Determine resolution based on target size and original resolution
            let width = originalWidth;
            let height = originalHeight;
            
            if (targetSizeMB <= 8) {
                // Small target: limit resolution
                if (width > 1280 || height > 720) {
                    const aspectRatio = width / height;
                    if (aspectRatio > 1) {
                        width = Math.min(width, 1280);
                        height = Math.round(width / aspectRatio);
                    } else {
                        height = Math.min(height, 720);
                        width = Math.round(height * aspectRatio);
                    }
                }
            } else if (targetSizeMB <= 25) {
                // Medium target: allow up to 1080p
                if (width > 1920 || height > 1080) {
                    const aspectRatio = width / height;
                    if (aspectRatio > 1) {
                        width = Math.min(width, 1920);
                        height = Math.round(width / aspectRatio);
                    } else {
                        height = Math.min(height, 1080);
                        width = Math.round(height * aspectRatio);
                    }
                }
            }
            // For 50MB+: keep original resolution
            
            // Make dimensions even (required for many codecs)
            width = Math.round(width / 2) * 2;
            height = Math.round(height / 2) * 2;
            
            // Choose codec based on target size
            let codec = 'avc1.42E01E'; // Default to H.264
            if (targetSizeMB >= 25) {
                // For larger targets, try HEVC for better compression
                codec = 'hev1.1.6.L93.B0';
            }
            
            return {
                codec: codec,
                bitrate: Math.round(videoBitrate),
                framerate: 30,
                keyframeInterval: 10,
                width: width,
                height: height,
                includeAudio: includeAudio,
                audioBitrate: audioBitrate,
                targetSize: targetSizeMB
            };
        }

        function debugLibraryLoading() {
            log('üîç Debugging library loading...', 'info');
            log(`üìä window.Mp4Muxer: ${typeof window.Mp4Muxer}`, 'info');
            log(`üìä global Mp4Muxer: ${typeof Mp4Muxer}`, 'info');
            
            // Check what's actually available in global scope
            const globalVars = Object.getOwnPropertyNames(window).filter(name => 
                name.toLowerCase().includes('mp4') || name.toLowerCase().includes('mux')
            );
            if (globalVars.length > 0) {
                log(`üîç Found MP4-related globals: ${globalVars.join(', ')}`, 'info');
            }
            
            // Try to access Mp4Muxer different ways
            if (typeof Mp4Muxer !== 'undefined' && Mp4Muxer) {
                log(`‚úÖ Mp4Muxer found directly`, 'success');
                log(`üìã Mp4Muxer properties: ${Object.keys(Mp4Muxer).join(', ')}`, 'info');
                return Mp4Muxer;
            } else if (window.Mp4Muxer) {
                log(`‚úÖ Mp4Muxer found on window object`, 'success');
                // Assign to global scope
                window.Mp4Muxer = window.Mp4Muxer;
                return window.Mp4Muxer;
            } else {
                log(`‚ùå Mp4Muxer not found in any expected location`, 'error');
                
                // More detailed debugging
                log(`üîç Checking script element...`, 'info');
                const scriptEl = document.getElementById('mp4MuxerScript');
                if (scriptEl) {
                    log(`üìä Script src: ${scriptEl.src}`, 'info');
                    log(`üìä Script loaded: ${scriptEl.complete}`, 'info');
                } else {
                    log(`‚ùå Script element not found`, 'error');
                }
                
                return null;
            }
        }

        function checkWebCodecsSupport() {
            log('üîç Checking WebCodecs support...', 'info');
            
            // Check WebCodecs API
            if (!('VideoEncoder' in window) || !('VideoDecoder' in window)) {
                log('‚ùå WebCodecs API is not supported in this browser', 'error');
                log('Please use Chrome 94+ or Edge 94+', 'warning');
                showError('WebCodecs API is not supported in this browser. Please use Chrome 94+ or Edge 94+.');
                return false;
            }
            log('‚úÖ WebCodecs API is supported', 'success');
            
            // Add detailed browser capability debugging
            log('üîç Browser capabilities:', 'info');
            log(`üì± User Agent: ${navigator.userAgent}`, 'info');
            log(`üñ•Ô∏è Platform: ${navigator.platform}`, 'info');
            log(`üöÄ Hardware Concurrency: ${navigator.hardwareConcurrency}`, 'info');
            
            // Check specific VideoEncoder capabilities
            if (VideoEncoder.isConfigSupported) {
                log('‚úÖ VideoEncoder.isConfigSupported available', 'success');
            } else {
                log('‚ùå VideoEncoder.isConfigSupported not available', 'error');
            }
            
            // Check MediaCapabilities API
            if ('mediaCapabilities' in navigator) {
                log('‚úÖ MediaCapabilities API available', 'success');
            } else {
                log('‚ö†Ô∏è MediaCapabilities API not available', 'warning');
            }
            
            // Check if we're in a secure context
            if (window.isSecureContext) {
                log('‚úÖ Secure context (HTTPS/localhost)', 'success');
            } else {
                log('‚ö†Ô∏è Not in secure context - some features may be limited', 'warning');
            }
            
            // Check Mp4Muxer with multiple methods
            const muxerObject = debugLibraryLoading();
            
            if (!muxerObject) {
                log('‚ùå MP4 Muxer library failed to load', 'error');
                log('This might be due to the script not loading properly', 'warning');
                showError('MP4 Muxer library failed to load. The script file might not be loading properly.');
                return false;
            }
            
            // Verify required classes are available
            const requiredClasses = ['Muxer', 'ArrayBufferTarget'];
            const missingClasses = requiredClasses.filter(className => !muxerObject[className]);
            
            if (missingClasses.length > 0) {
                log(`‚ùå Missing required Mp4Muxer classes: ${missingClasses.join(', ')}`, 'error');
                showError(`MP4 Muxer library is incomplete. Missing: ${missingClasses.join(', ')}`);
                return false;
            }
            
            // Test creating objects
            try {
                const testTarget = new muxerObject.ArrayBufferTarget();
                log('‚úÖ Test ArrayBufferTarget created successfully', 'success');
                
                const testMuxer = new muxerObject.Muxer({
                    target: testTarget,
                    video: { codec: 'avc', width: 640, height: 480 },
                    fastStart: 'in-memory'
                });
                log('‚úÖ Test Muxer created successfully', 'success');
            } catch (e) {
                log(`‚ùå Error testing Mp4Muxer functionality: ${e.message}`, 'error');
                showError(`MP4 Muxer library loaded but not working properly: ${e.message}`);
                return false;
            }
            
            log('‚úÖ MP4 Muxer library loaded and tested successfully', 'success');
            log(`üìã Available classes: ${Object.keys(muxerObject).join(', ')}`, 'info');
            return true;
        }

        function showError(message) {
            // Create error modal
            const errorModal = document.createElement('div');
            errorModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            const errorContent = document.createElement('div');
            errorContent.style.cssText = `
                background: #ff6b6b;
                color: white;
                padding: 30px;
                border-radius: 15px;
                max-width: 600px;
                text-align: center;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            `;
            
            // Detect specific issues and provide solutions
            let troubleshooting = '';
            if (!('VideoEncoder' in window)) {
                troubleshooting = `
                    <div style="text-align: left; margin: 20px 0; background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                        <h4>üîß Solutions:</h4>
                        <ul style="margin: 10px 0;">
                            <li>Update to Chrome 94+ or Edge 94+</li>
                            <li>Enable "Experimental Web Platform features" in chrome://flags/</li>
                            <li>Make sure you're not using an old browser version</li>
                        </ul>
                    </div>
                `;
            } else if (typeof Mp4Muxer === 'undefined') {
                troubleshooting = `
                    <div style="text-align: left; margin: 20px 0; background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                        <h4>üîß Possible Solutions:</h4>
                        <ul style="margin: 10px 0;">
                            <li>Refresh the page and try again</li>
                            <li>Check your internet connection</li>
                            <li>Disable browser extensions temporarily</li>
                            <li>Try opening in an incognito/private window</li>
                            <li>Check if browser is blocking JavaScript</li>
                        </ul>
                    </div>
                `;
            }
            
            errorContent.innerHTML = `
                <h2>‚ö†Ô∏è Video Processing Unavailable</h2>
                <p style="margin: 20px 0; line-height: 1.6;">${message}</p>
                ${troubleshooting}
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    <button onclick="location.reload()" style="
                        background: white;
                        color: #ff6b6b;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-weight: bold;
                    ">üîÑ Refresh Page</button>
                    <button onclick="this.parentElement.parentElement.parentElement.remove()" style="
                        background: rgba(255,255,255,0.2);
                        color: white;
                        border: 1px solid white;
                        padding: 10px 20px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-weight: bold;
                    ">‚úï Close</button>
                </div>
            `;
            
            errorModal.appendChild(errorContent);
            document.body.appendChild(errorModal);
            
            compressBtn.disabled = true;
            compressBtn.textContent = '‚ùå Compression Unavailable';
        }

        function setupEventListeners() {
            videoInput.addEventListener('change', handleFileSelect);
            compressBtn.addEventListener('click', startCompression);
            downloadBtn.addEventListener('click', downloadCompressedVideo);
            
            // Mode switching event listeners
            basicModeBtn.addEventListener('click', switchToBasicMode);
            advancedModeBtn.addEventListener('click', switchToAdvancedMode);
            
            // File size selection event listeners
            fileSizeBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    selectedTargetSize = parseInt(this.dataset.size);
                    updateSelectedSize();
                    localStorage.setItem('videoCompressorTargetSize', selectedTargetSize.toString());
                    log(`üéØ Target size set to ${selectedTargetSize}MB`, 'info');
                });
            });
            
            // Quality preset handling (for advanced mode)
            document.getElementById('quality').addEventListener('change', function() {
                const quality = this.value;
                const bitrateInput = document.getElementById('bitrate');
                
                if (quality !== 'custom' && qualityPresets[quality]) {
                    bitrateInput.value = qualityPresets[quality].bitrate;
                    bitrateInput.disabled = true;
                } else {
                    bitrateInput.disabled = false;
                }
            });
        }

        function setupDragAndDrop() {
            const dropZone = document.querySelector('.file-input-label');
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            function highlight(e) {
                dropZone.style.borderColor = '#4ecdc4';
                dropZone.style.background = 'rgba(78, 205, 196, 0.2)';
            }

            function unhighlight(e) {
                dropZone.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                dropZone.style.background = 'rgba(255, 255, 255, 0.05)';
            }

            dropZone.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type.startsWith('video/')) {
                        videoInput.files = files;
                        handleFileSelect({ target: { files: files } });
                    } else {
                        log('‚ùå Please select a valid video file', 'error');
                    }
                }
            }
        }

        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            originalVideoFile = file;
            log(`üìÅ Selected file: ${file.name}`, 'success');

            try {
                await loadVideoPreview(file);
                showFileInfo(file);
                compressBtn.disabled = false;
            } catch (error) {
                log(`‚ùå Error loading video: ${error.message}`, 'error');
            }
        }

        async function loadVideoPreview(file) {
            return new Promise((resolve, reject) => {
                const url = URL.createObjectURL(file);
                originalVideoEl.src = url;
                
                originalVideoEl.addEventListener('loadedmetadata', function() {
                    const duration = formatDuration(this.duration);
                    const resolution = `${this.videoWidth}x${this.videoHeight}`;
                    const size = formatFileSize(file.size);
                    
                    document.getElementById('originalInfo').textContent = 
                        `${resolution} ‚Ä¢ ${duration} ‚Ä¢ ${size}`;
                    
                    previewSection.classList.remove('hidden');
                    
                    // Update resolution dropdown with original
                    const resolutionSelect = document.getElementById('resolution');
                    const originalOption = resolutionSelect.querySelector('option[value="original"]');
                    originalOption.textContent = `Keep Original (${resolution})`;
                    
                    resolve();
                }, { once: true });

                originalVideoEl.addEventListener('error', function() {
                    URL.revokeObjectURL(url);
                    reject(new Error('Failed to load video'));
                }, { once: true });
            });
        }

        function showFileInfo(file) {
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileSize').textContent = formatFileSize(file.size);
            
            originalVideoEl.addEventListener('loadedmetadata', function() {
                document.getElementById('fileDuration').textContent = formatDuration(this.duration);
                document.getElementById('fileResolution').textContent = `${this.videoWidth}x${this.videoHeight}`;
            }, { once: true });
            
            fileInfo.classList.remove('hidden');
        }

        async function startCompression() {
            if (isProcessing || !originalVideoFile) return;

            isProcessing = true;
            compressBtn.disabled = true;
            downloadBtn.classList.add('hidden');
            progressSection.style.display = 'block';
            
            log('üîÑ Starting video compression...', 'success');

            try {
                const settings = getCompressionSettings();
                await compressVideo(originalVideoFile, settings);
                
                log('‚úÖ Video compression completed successfully!', 'success');
                downloadBtn.classList.remove('hidden');
                downloadBtn.disabled = false;
                
            } catch (error) {
                log(`‚ùå Compression failed: ${error.message}`, 'error');
                console.error('Compression error:', error);
            } finally {
                isProcessing = false;
                compressBtn.disabled = false;
                progressSection.style.display = 'none';
            }
        }

        function getCompressionSettings() {
            if (currentSettingsMode === 'basic') {
                // Basic mode: calculate settings based on target file size
                const includeAudio = document.getElementById('basicIncludeAudio').checked;
                const duration = originalVideoEl.duration;
                const originalWidth = originalVideoEl.videoWidth;
                const originalHeight = originalVideoEl.videoHeight;
                
                const settings = calculateBasicSettings(
                    selectedTargetSize, 
                    duration, 
                    originalWidth, 
                    originalHeight, 
                    includeAudio
                );
                
                log(`üéØ Basic mode settings: ${selectedTargetSize}MB target, ${settings.width}x${settings.height}, ${(settings.bitrate/1000000).toFixed(1)}Mbps`, 'info');
                return settings;
                
            } else {
                // Advanced mode: use form inputs
                const codec = document.getElementById('codec').value;
                const bitrate = parseFloat(document.getElementById('bitrate').value) * 1000000; // Convert to bps
                const framerate = 30; // Default framerate
                const keyframeInterval = 10; // Default keyframe interval
                const resolution = document.getElementById('resolution').value;
                const includeAudio = document.getElementById('includeAudio').value === 'true';
                const audioBitrate = parseInt(document.getElementById('audioBitrate').value) * 1000; // Convert to bps
                
                let width = originalVideoEl.videoWidth;
                let height = originalVideoEl.videoHeight;
                
                if (resolution !== 'original') {
                    [width, height] = resolution.split('x').map(Number);
                }

                return {
                    codec,
                    bitrate,
                    framerate,
                    keyframeInterval,
                    width,
                    height,
                    includeAudio,
                    audioBitrate
                };
            }
        }

        async function compressVideo(file, settings) {
            // Get Mp4Muxer with fallback
            let Mp4MuxerLib = null;
            if (typeof Mp4Muxer !== 'undefined' && Mp4Muxer) {
                Mp4MuxerLib = Mp4Muxer;
            } else if (window.Mp4Muxer) {
                Mp4MuxerLib = window.Mp4Muxer;
            } else {
                throw new Error('MP4 Muxer library is not available');
            }
            
            updateProgress(0, 'Initializing compression...');
            log('üîß Starting compression with settings:', 'info');
            log(`üìä Codec: ${settings.codec}, Bitrate: ${settings.bitrate}, Resolution: ${settings.width}x${settings.height}`, 'info');
            
            // Check for audio support
            const hasAudioCodecs = 'AudioEncoder' in window && 'AudioDecoder' in window;
            const shouldIncludeAudio = settings.includeAudio && hasAudioCodecs;
            log(`üéµ Audio support: ${hasAudioCodecs ? 'Available' : 'Not available'}`, hasAudioCodecs ? 'success' : 'warning');
            log(`üéµ Include audio: ${shouldIncludeAudio ? 'Yes' : 'No'}`, shouldIncludeAudio ? 'success' : 'info');
            
            // Create muxer with audio support
            const muxerConfig = {
                target: new Mp4MuxerLib.ArrayBufferTarget(),
                video: {
                    codec: settings.codec.startsWith('avc') ? 'avc' : 
                           settings.codec.startsWith('hev') ? 'hevc' : 
                           settings.codec.startsWith('vp9') ? 'vp9' : 'av1',
                    width: settings.width,
                    height: settings.height
                },
                fastStart: 'in-memory'
            };
            
            // Add audio configuration if supported
            if (shouldIncludeAudio) {
                muxerConfig.audio = {
                    codec: 'aac',
                    numberOfChannels: 2,
                    sampleRate: 48000
                };
                log(`üéµ Audio encoding enabled (AAC, 48kHz, Stereo, ${settings.audioBitrate/1000}kbps)`, 'success');
            }
            
            const muxer = new Mp4MuxerLib.Muxer(muxerConfig);

            // Setup video encoder
            const videoEncoder = new VideoEncoder({
                output: (chunk, meta) => {
                    muxer.addVideoChunk(chunk, meta);
                },
                error: (e) => {
                    throw new Error(`Video encoder error: ${e.message}`);
                }
            });

            // Setup audio encoder if supported
            let audioEncoder = null;
            if (shouldIncludeAudio) {
                audioEncoder = new AudioEncoder({
                    output: (chunk, meta) => {
                        muxer.addAudioChunk(chunk, meta);
                    },
                    error: (e) => {
                        log(`‚ö†Ô∏è Audio encoder error: ${e.message}`, 'warning');
                    }
                });
            }

            // Check video codec support
            const encoderConfig = {
                codec: settings.codec,
                width: settings.width,
                height: settings.height,
                bitrate: settings.bitrate,
                framerate: settings.framerate,
                keyFrameEvery: settings.keyframeInterval
            };

            log(`üîç Checking codec support for: ${settings.codec}`, 'info');
            let { supported } = await VideoEncoder.isConfigSupported(encoderConfig);
            
            // If primary codec not supported, try fallbacks
            if (!supported) {
                log(`‚ö†Ô∏è Primary codec ${settings.codec} not supported, trying fallbacks...`, 'warning');
                
                const fallbackCodecs = {
                    'avc1.42E01E': ['avc1.42001E', 'avc1.4D001E', 'avc1.420028', 'avc1.42001F', 'avc1.42E028', 'avc1'],
                    'hev1.1.6.L93.B0': ['hvc1.1.6.L93.B0', 'hev1', 'hvc1'],
                    'vp09.00.10.08': ['vp09.00.10.08.01', 'vp9.0', 'vp9'],
                    'av01.0.04M.08': ['av01.0.05M.08', 'av01.0.08M.08', 'av1']
                };
                
                const fallbacks = fallbackCodecs[settings.codec] || [];
                
                for (const fallbackCodec of fallbacks) {
                    log(`üîç Trying fallback codec: ${fallbackCodec}`, 'info');
                    
                    // Try different configurations
                    const configs = [
                        { ...encoderConfig, codec: fallbackCodec },
                        { ...encoderConfig, codec: fallbackCodec, hardwareAcceleration: 'prefer-hardware' },
                        { ...encoderConfig, codec: fallbackCodec, hardwareAcceleration: 'prefer-software' },
                        { ...encoderConfig, codec: fallbackCodec, hardwareAcceleration: 'no-preference' }
                    ];
                    
                    for (const config of configs) {
                        try {
                            const result = await VideoEncoder.isConfigSupported(config);
                            if (result.supported) {
                                log(`‚úÖ Found working codec: ${config.codec} (${config.hardwareAcceleration || 'default'})`, 'success');
                                Object.assign(encoderConfig, config);
                                settings.codec = config.codec;
                                supported = true;
                                break;
                            }
                        } catch (e) {
                            log(`‚ùå Failed ${fallbackCodec}: ${e.message}`, 'warning');
                        }
                    }
                    
                    if (supported) break;
                }
                
                // If still not supported, try the most basic configurations
                if (!supported) {
                    log(`üîÑ Trying basic configurations...`, 'info');
                    
                    const basicCodecs = ['avc1', 'vp8', 'vp9'];
                    for (const basicCodec of basicCodecs) {
                        try {
                            // Very basic configuration
                            const basicConfig = {
                                codec: basicCodec,
                                width: Math.min(settings.width, 1280),
                                height: Math.min(settings.height, 720),
                                bitrate: Math.min(settings.bitrate, 1000000),
                                framerate: Math.min(settings.framerate, 30),
                                hardwareAcceleration: 'no-preference'
                            };
                            
                            const result = await VideoEncoder.isConfigSupported(basicConfig);
                            if (result.supported) {
                                log(`‚úÖ Using basic codec: ${basicCodec} with reduced settings`, 'success');
                                Object.assign(encoderConfig, basicConfig);
                                settings.codec = basicCodec;
                                settings.width = basicConfig.width;
                                settings.height = basicConfig.height;
                                settings.bitrate = basicConfig.bitrate;
                                settings.framerate = basicConfig.framerate;
                                supported = true;
                                break;
                            }
                        } catch (e) {
                            log(`‚ùå Basic codec ${basicCodec} failed: ${e.message}`, 'warning');
                        }
                    }
                }
            }
            
            if (!supported) {
                const errorMessage = `No supported video codec found. This usually means:\n\n` +
                    `üîß Possible Solutions:\n` +
                    `‚Ä¢ Enable hardware acceleration in browser settings\n` +
                    `‚Ä¢ Try Chrome://flags and enable "WebCodecs API"\n` +
                    `‚Ä¢ Update your graphics drivers\n` +
                    `‚Ä¢ Try a different browser (Chrome 94+ recommended)\n` +
                    `‚Ä¢ Check if your GPU supports video encoding\n\n` +
                    `üí° Your browser supports WebCodecs but no video encoder configuration works.`;
                throw new Error(errorMessage);
            }
            log(`‚úÖ Video codec ${encoderConfig.codec} is supported`, 'success');

            videoEncoder.configure(encoderConfig);
            
            // Configure audio encoder if available
            if (audioEncoder) {
                const audioConfig = {
                    codec: 'mp4a.40.2', // AAC-LC
                    numberOfChannels: 2,
                    sampleRate: 48000,
                    bitrate: settings.audioBitrate // Use user-selected bitrate
                };
                
                try {
                    const audioSupported = await AudioEncoder.isConfigSupported(audioConfig);
                    if (audioSupported.supported) {
                        audioEncoder.configure(audioConfig);
                        log(`‚úÖ Audio codec AAC is supported (${settings.audioBitrate/1000}kbps)`, 'success');
                    } else {
                        log(`‚ö†Ô∏è AAC not supported, audio will be skipped`, 'warning');
                        audioEncoder = null;
                    }
                } catch (e) {
                    log(`‚ö†Ô∏è Audio encoder configuration failed: ${e.message}`, 'warning');
                    audioEncoder = null;
                }
            }
            
            updateProgress(10, 'Setting up video processing...');

            // Extract audio using MediaSource API
            let audioTrack = null;
            if (audioEncoder) {
                try {
                    audioTrack = await extractAudioTrack(file);
                    if (audioTrack) {
                        if (audioTrack instanceof AudioBuffer) {
                            log(`üéµ Audio buffer extracted successfully`, 'success');
                        } else if (audioTrack && audioTrack.hasAudio) {
                            log(`üéµ Audio track detected (fallback method)`, 'success');
                        } else {
                            log(`‚ö†Ô∏è No audio track found in video`, 'warning');
                            audioTrack = null;
                        }
                    } else {
                        log(`‚ö†Ô∏è No audio track found in video`, 'warning');
                    }
                } catch (e) {
                    log(`‚ö†Ô∏è Failed to extract audio: ${e.message}`, 'warning');
                    audioTrack = null;
                }
            }

            // Create video element for frame extraction
            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.muted = true;
            
            await new Promise((resolve, reject) => {
                video.addEventListener('loadedmetadata', resolve, { once: true });
                video.addEventListener('error', reject, { once: true });
            });

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = settings.width;
            canvas.height = settings.height;

            const duration = video.duration;
            const frameCount = Math.floor(duration * settings.framerate);
            const frameInterval = 1 / settings.framerate;
            
            log(`üìä Processing ${frameCount} frames at ${settings.framerate}fps`, 'success');
            log(`‚è±Ô∏è Video duration: ${duration.toFixed(2)}s`, 'info');

            // Process audio in parallel if available
            let audioProcessing = null;
            if (audioTrack && audioEncoder) {
                audioProcessing = processAudioTrack(audioTrack, audioEncoder, duration)
                    .catch(error => {
                        log(`‚ö†Ô∏è Audio processing failed, continuing without audio: ${error.message}`, 'warning');
                        return null; // Continue without audio
                    });
            }

            // Process video frames
            for (let i = 0; i < frameCount; i++) {
                const time = i * frameInterval;
                
                if (time >= duration) break;

                video.currentTime = time;
                await new Promise(resolve => {
                    video.addEventListener('seeked', resolve, { once: true });
                });

                // Draw frame to canvas
                ctx.drawImage(video, 0, 0, settings.width, settings.height);
                
                // Create video frame
                const timestamp = time * 1000000; // Convert to microseconds
                const frame = new VideoFrame(canvas, { timestamp });
                
                // Encode frame
                const keyFrame = i % settings.keyframeInterval === 0;
                videoEncoder.encode(frame, { keyFrame });
                
                frame.close();
                
                // Update progress
                const progress = 10 + (i / frameCount) * 70;
                updateProgress(progress, `Processing frame ${i + 1}/${frameCount}`);
                
                // Log progress every 30 frames
                if (i % 30 === 0) {
                    log(`üé¨ Processed ${i + 1}/${frameCount} frames (${(progress).toFixed(1)}%)`, 'info');
                }
            }

            updateProgress(80, 'Finalizing video...');
            log('üîÑ Flushing video encoder...', 'info');
            
            // Finish video encoding
            await videoEncoder.flush();
            videoEncoder.close();
            
            // Wait for audio processing to complete
            if (audioProcessing) {
                updateProgress(85, 'Finalizing audio...');
                log('üîÑ Waiting for audio processing...', 'info');
                await audioProcessing;
            }
            
            // Finalize muxer
            updateProgress(90, 'Creating final video...');
            muxer.finalize();

            updateProgress(95, 'Creating download file...');

            // Create blob from muxer output
            const { buffer } = muxer.target;
            compressedVideoBlob = new Blob([buffer], { type: 'video/mp4' });
            
            // Show compressed video preview
            const compressedUrl = URL.createObjectURL(compressedVideoBlob);
            compressedVideoEl.src = compressedUrl;
            
            await new Promise((resolve, reject) => {
                compressedVideoEl.addEventListener('loadedmetadata', resolve, { once: true });
                compressedVideoEl.addEventListener('error', reject, { once: true });
            });

            const originalSize = formatFileSize(file.size);
            const compressedSize = formatFileSize(compressedVideoBlob.size);
            const compressionRatio = ((1 - compressedVideoBlob.size / file.size) * 100).toFixed(1);
            
            const audioStatus = audioTrack ? 'üéµ' : 'üîá';
            document.getElementById('compressedInfo').textContent = 
                `${settings.width}x${settings.height} ‚Ä¢ ${formatDuration(compressedVideoEl.duration)} ‚Ä¢ ${compressedSize} (${compressionRatio}% smaller) ${audioStatus}`;

            updateProgress(100, 'Compression complete!');
            
            log(`üìà Compression ratio: ${compressionRatio}% smaller`, 'success');
            log(`üìÅ Original size: ${originalSize} ‚Üí Compressed size: ${compressedSize}`, 'success');
            if (audioTrack) {
                log(`üéµ Audio included in compressed video`, 'success');
            } else {
                log(`üîá No audio track in compressed video`, 'warning');
            }

            // Clean up
            URL.revokeObjectURL(video.src);
        }

        // Function to extract audio track from video file
        async function extractAudioTrack(file) {
            try {
                // Use Web Audio API to extract audio
                const arrayBuffer = await file.arrayBuffer();
                
                // Create audio context
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                try {
                    // Decode audio data
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    await audioContext.close();
                    
                    log(`üéµ Audio decoded: ${audioBuffer.duration.toFixed(2)}s, ${audioBuffer.numberOfChannels} channels, ${audioBuffer.sampleRate}Hz`, 'success');
                    return audioBuffer;
                } catch (decodeError) {
                    await audioContext.close();
                    
                    // Fallback: try to detect if video has audio
                    const video = document.createElement('video');
                    const url = URL.createObjectURL(file);
                    video.src = url;
                    
                    return new Promise((resolve, reject) => {
                        video.addEventListener('loadedmetadata', () => {
                            URL.revokeObjectURL(url);
                            
                            // Check various ways to detect audio
                            if (video.webkitAudioDecodedByteCount !== undefined && video.webkitAudioDecodedByteCount > 0) {
                                log('üéµ Audio detected via webkit property', 'success');
                                resolve({ hasAudio: true, element: video });
                            } else if (video.mozHasAudio !== undefined && video.mozHasAudio) {
                                log('üéµ Audio detected via mozilla property', 'success');
                                resolve({ hasAudio: true, element: video });
                            } else {
                                log('‚ö†Ô∏è Could not decode audio data, trying fallback method', 'warning');
                                resolve({ hasAudio: false, element: video });
                            }
                        });
                        
                        video.addEventListener('error', () => {
                            URL.revokeObjectURL(url);
                            resolve(null);
                        });
                    });
                }
            } catch (error) {
                log(`‚ö†Ô∏è Audio extraction failed: ${error.message}`, 'warning');
                return null;
            }
        }

        // Function to process audio track
        async function processAudioTrack(audioData, audioEncoder, duration) {
            try {
                log('üéµ Starting audio processing...', 'info');
                
                // Handle different types of audio data
                if (audioData instanceof AudioBuffer) {
                    // Process decoded audio buffer
                    return await processAudioBuffer(audioData, audioEncoder);
                } else if (audioData && audioData.hasAudio && audioData.element) {
                    // Process using media element (fallback)
                    return await processAudioElement(audioData.element, audioEncoder, duration);
                } else {
                    throw new Error('Invalid audio data format');
                }
                
            } catch (error) {
                log(`‚ö†Ô∏è Audio processing failed: ${error.message}`, 'warning');
                throw error;
            }
        }

        // Process audio buffer (preferred method)
        async function processAudioBuffer(audioBuffer, audioEncoder) {
            const sampleRate = 48000; // Target sample rate for AAC
            const frameSize = 1024; // AAC frame size
            const numberOfChannels = 2; // Stereo output
            
            // Resample if necessary
            let processedBuffer = audioBuffer;
            if (audioBuffer.sampleRate !== sampleRate) {
                log(`üîÑ Resampling audio from ${audioBuffer.sampleRate}Hz to ${sampleRate}Hz`, 'info');
                
                const offlineContext = new OfflineAudioContext(numberOfChannels, 
                    Math.ceil(audioBuffer.duration * sampleRate), sampleRate);
                
                const source = offlineContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(offlineContext.destination);
                source.start();
                
                processedBuffer = await offlineContext.startRendering();
            }
            
            // Convert to stereo if mono
            let leftChannel, rightChannel;
            if (processedBuffer.numberOfChannels === 1) {
                leftChannel = processedBuffer.getChannelData(0);
                rightChannel = leftChannel; // Duplicate mono to both channels
            } else {
                leftChannel = processedBuffer.getChannelData(0);
                rightChannel = processedBuffer.numberOfChannels > 1 ? 
                    processedBuffer.getChannelData(1) : leftChannel;
            }
            
            // Process audio in chunks
            const totalFrames = Math.ceil(processedBuffer.length / frameSize);
            let currentTime = 0;
            
            for (let i = 0; i < totalFrames; i++) {
                const startSample = i * frameSize;
                const endSample = Math.min(startSample + frameSize, processedBuffer.length);
                const actualFrameSize = endSample - startSample;
                
                if (actualFrameSize === 0) break;
                
                // Create audio data for this chunk
                const audioData = new Float32Array(actualFrameSize * 2);
                
                // Interleave samples
                for (let j = 0; j < actualFrameSize; j++) {
                    audioData[j * 2] = leftChannel[startSample + j] || 0;
                    audioData[j * 2 + 1] = rightChannel[startSample + j] || 0;
                }
                
                // Create AudioData frame
                const audioFrame = new AudioData({
                    format: 'f32',
                    sampleRate: sampleRate,
                    numberOfFrames: actualFrameSize,
                    numberOfChannels: numberOfChannels,
                    timestamp: currentTime * 1000000, // Convert to microseconds
                    data: audioData
                });
                
                // Encode the frame
                audioEncoder.encode(audioFrame);
                audioFrame.close();
                
                currentTime += actualFrameSize / sampleRate;
                
                // Log progress occasionally
                if (i % 100 === 0) {
                    const progress = (i / totalFrames) * 100;
                    log(`üéµ Audio encoding progress: ${progress.toFixed(1)}%`, 'info');
                }
            }
            
            log('üéµ Audio buffer processing completed', 'success');
        }

        // Process audio element (fallback method)
        async function processAudioElement(videoElement, audioEncoder, duration) {
            log('üéµ Using fallback audio processing method', 'info');
            
            return new Promise((resolve, reject) => {
                try {
                    // Create audio context
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 48000
                    });
                    
                    // Create media element source
                    const source = audioContext.createMediaElementSource(videoElement);
                    
                    // Create analyser for monitoring
                    const analyser = audioContext.createAnalyser();
                    analyser.fftSize = 2048;
                    
                    // Create destination for processing
                    const destination = audioContext.createMediaStreamDestination();
                    
                    // Connect audio graph
                    source.connect(analyser);
                    analyser.connect(destination);
                    
                    // Use MediaRecorder to capture audio
                    const mediaRecorder = new MediaRecorder(destination.stream, {
                        mimeType: 'audio/webm; codecs=opus'
                    });
                    
                    const audioChunks = [];
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = async () => {
                        try {
                            // Process recorded audio
                            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                            const arrayBuffer = await audioBlob.arrayBuffer();
                            
                            // Decode and re-encode
                            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                            await processAudioBuffer(audioBuffer, audioEncoder);
                            
                            audioContext.close();
                            resolve();
                        } catch (error) {
                            audioContext.close();
                            reject(error);
                        }
                    };
                    
                    // Start recording and play video
                    mediaRecorder.start();
                    videoElement.currentTime = 0;
                    videoElement.muted = true;
                    
                    videoElement.addEventListener('ended', () => {
                        mediaRecorder.stop();
                    });
                    
                    videoElement.play().catch(reject);
                    
                } catch (error) {
                    reject(error);
                }
            });
        }

        function downloadCompressedVideo() {
            if (!compressedVideoBlob) return;

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `compressed_video_${timestamp}.mp4`;
            
            const url = URL.createObjectURL(compressedVideoBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log(`üíæ Downloaded: ${filename}`, 'success');
        }

        function updateProgress(percentage, text) {
            progressFill.style.width = `${percentage}%`;
            progressText.textContent = text;
        }

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            console.log(`[VideoCompressor] ${message}`);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatDuration(seconds) {
            if (isNaN(seconds)) return '0:00';
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        async function checkCodecSupport() {
            log('üîç Checking available codec support...', 'info');
            
            const codecs = [
                { value: 'avc1.42E01E', name: 'H.264 (AVC)', fallbacks: ['avc1.42001E', 'avc1.4D001E', 'avc1'] },
                { value: 'hev1.1.6.L93.B0', name: 'H.265 (HEVC)', fallbacks: ['hvc1.1.6.L93.B0', 'hev1'] },
                { value: 'vp09.00.10.08', name: 'VP9', fallbacks: ['vp09.00.10.08.01', 'vp9'] },
                { value: 'av01.0.04M.08', name: 'AV1', fallbacks: ['av01.0.05M.08', 'av01.0.08M.08', 'av1'] }
            ];
            
            const codecSelect = document.getElementById('codec');
            const supportedCodecs = [];
            
            for (const codec of codecs) {
                let supported = false;
                let workingCodec = codec.value;
                
                // Test primary codec
                try {
                    const config = {
                        codec: codec.value,
                        width: 640,
                        height: 480,
                        bitrate: 1000000,
                        framerate: 30
                    };
                    
                    const result = await VideoEncoder.isConfigSupported(config);
                    supported = result.supported;
                } catch (e) {
                    // Codec not supported
                }
                
                // If primary not supported, try fallbacks
                if (!supported) {
                    for (const fallback of codec.fallbacks) {
                        try {
                            const config = {
                                codec: fallback,
                                width: 640,
                                height: 480,
                                bitrate: 1000000,
                                framerate: 30
                            };
                            
                            const result = await VideoEncoder.isConfigSupported(config);
                            if (result.supported) {
                                supported = true;
                                workingCodec = fallback;
                                break;
                            }
                        } catch (e) {
                            // Continue to next fallback
                        }
                    }
                }
                
                // Update option based on support
                const option = codecSelect.querySelector(`option[value="${codec.value}"]`);
                if (option) {
                    if (supported) {
                        option.textContent = `${codec.name} - ‚úÖ Supported`;
                        option.dataset.workingCodec = workingCodec;
                        supportedCodecs.push(codec.name);
                        log(`‚úÖ ${codec.name} supported (using ${workingCodec})`, 'success');
                    } else {
                        option.textContent = `${codec.name} - ‚ùå Not Supported`;
                        option.disabled = true;
                        log(`‚ùå ${codec.name} not supported`, 'warning');
                    }
                }
            }
            
            if (supportedCodecs.length > 0) {
                log(`üéØ Supported codecs: ${supportedCodecs.join(', ')}`, 'success');
            } else {
                log(`‚ö†Ô∏è No advanced codecs supported, will fallback to basic H.264`, 'warning');
            }
        }
    </script>
</body>
</html> 